parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractTParser;

    // Use the vocabulary generated by the accompanying
    // lexer.
    //
    tokenVocab = TLexer;
}

// Some imaginary tokens for tree rewrites
//
tokens {
	PARAM;
	ARGUMENT;
}

// What package should the generated source exist in?
//
@header {

    package nl.utwente.cs.essig;
}

// Parser
//
microcontroller:	IDENTIFIER^ LBRACK! parameters registers instructions RBRACK! EOF!;

parameters:		PARAMETERS LBRACK (parameter LINE_SEPERATOR)+ RBRACK
		-> ^(PARAMETERS parameter+);
parameter:		RAM^ NUMBER
	|		GPRS^ NUMBER
	|		SIZE^ NUMBER
	|		CLOCK^ NUMBER
	;

registers:		REGISTERS LBRACK (register LINE_SEPERATOR)+ RBRACK
		-> ^(REGISTERS register+);
register:		IDENTIFIER;

instructions:		INSTRUCTIONS^ LBRACK! instruction+ RBRACK!;
instruction:		IDENTIFIER params? arguments? LBRACK expr+ RBRACK
		-> ^(IDENTIFIER ^(PARAM params?) ^(ARGUMENT arguments?) expr+);


params:			LBRACE param (ARG_SEPERATOR param)* RBRACE
		-> param+;

param	:		SIZE^ ASSIGN! NUMBER
	|		CLOCK^ ASSIGN! NUMBER
	|		OP_CODE^ ASSIGN! OPCODE
	;

arguments:		argument (ARG_SEPERATOR argument)*
		-> argument+;

argument :		IDENTIFIER;

expr	:		assignExpr LINE_SEPERATOR!
	|		ifExpr;

assignExpr:		IDENTIFIER ASSIGN^ operatorExpr;

ifExpr:			IF^ condition LBRACK! expr+ RBRACK! (ELSE LBRACK! expr+ RBRACK!)?;

operatorExpr:		word (operator^ operatorExpr)?;

condition:		word EQUALS^ word
	|		LPAREN! operatorExpr RPAREN! EQUALS^ word
	;

word	:		NOT? IDENTIFIER^ (LPAREN! (IDENTIFIER | NUMBER) RPAREN!)?
	|		NUMBER
	;

operator:		AND | OR | XOR | ADD;
