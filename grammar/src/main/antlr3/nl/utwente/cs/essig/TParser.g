parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractTParser;

    // Use the vocabulary generated by the accompanying
    // lexer.
    //
    tokenVocab = TLexer;
}

// Some imaginary tokens for tree rewrites
//
//tokens {
//}

// What package should the generated source exist in?
//
@header {

    package nl.utwente.cs.essig;
}

// Parser
//
microcontroller:	IDENTIFIER^ LBRACK! parameters registers instructions RBRACK! EOF!;

parameters:		PARAMETERS^ LBRACK! (parameter LINE_SEPERATOR!)+ RBRACK!;
parameter:		RAM NUMBER
	|		GPRS NUMBER
	|   IDENTIFIER ASSIGN! (NUMBER | opcode)
	;

registers:		REGISTERS^ LBRACK! (register LINE_SEPERATOR!)+ RBRACK!;
register:		IDENTIFIER;

instructions:		INSTRUCTIONS^ LBRACK! instruction+ RBRACK!;
instruction:		IDENTIFIER^ params? arguments?  LBRACK! expr+ RBRACK!;


params : LBRACE! param (ARG_SEPERATOR! param)* RBRACE!;
param : IDENTIFIER ASSIGN! (NUMBER | opcode);

// Params
opcode	:		OP_CODE^ (NUMBER | opcode_param)* ;
opcode_param	:	IDENTIFIER (LBRACE! NUMBER RBRACE!)?;

//clock_cycles : CLOCK^ ASSIGN! NUMBER;
//size : SIZE^ ASSIGN! NUMBER;   

arguments:		argument (ARG_SEPERATOR! argument)*;

argument : IDENTIFIER;

expr	:		assignExpr LINE_SEPERATOR!
	|		ifExpr;

assignExpr:		IDENTIFIER ASSIGN^ word (operator word)*;
ifExpr:			IF^ condition LBRACK! expr+ RBRACK! (ELSE LBRACK! expr+ RBRACK!)?;

condition:		(word | (LPAREN! word operator word RPAREN!))  EQUALS word;
word:			NOT? (IDENTIFIER (LPAREN! word RPAREN!)?| NUMBER);

operator:		AND | OR | XOR | ADD;
