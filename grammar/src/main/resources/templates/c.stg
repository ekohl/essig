group c;

microcontroller(name,parameters,registers,instructions) ::= <<
#include \<stdio.h\>
#include "simulator.h"

// Spec for <name>

// Parameters
<parameters; separator="\n">
// End of parameters

// FIXME: Hardcoded parameters
int npins = 0;
size_t pinoffset = 0;
int nbits_cpu = 16;
bool is_big_endian = false;

// Registers
int nregisters = <length(registers)>;
Register registers[] = {
	<registers:{\{ "<it.name>", <it.name> \}}; separator=",\n">

 };
// End of registers

// helper functions (should be in VM I Think)
bool GetBit(int b, int pos)
{
	return ((b & (1 \<\< pos)) != 0);
}

void AddBit(int *val, int source, int pos)
{
	*val \<\<=1;
	*val |= GetBit(source,pos);
} 

// Instructions
<instructions; separator="\n">

OpcodeHandler opcode_handlers[] = {
	<instructions:opcodehandler(); separator=",\n">,
	0
};
// End of instructions
>>

opcodehandler(it) ::= <<
{ "<it.name>", 0b<it.opcode>, 0b<it.mask>, (opcode_handler *) <it.name>,<it.next_is_arg> }
>>

param(name,value) ::= <<
<name> = <value>;
>>

cycles(cycles) ::= <<
state->cycles += <cycles>;
>>

register(name) ::= <<
"<name>"
>>

ram (ram) ::= <<
size_t ramsize = <ram>;
>>

clock (clock) ::= <<
// Standard value for Clock Cycles for 1 instruction.
int standard_clock = <clock>;
>>

instruction_return_size (size) ::= <<
// Standard size (words) of 1 instruction return value;
int instruction_return_size = <size>;
>>

instruction(name,params,arguments,expressions) ::= <<
bool <name> (VMState * state, VMStateDiff *diff, OPCODE_TYPE opcode) {
	// error
	bool error = false;

	// result
	int result = 0;

	
	<params; separator="\n">

	// Decode the opcode
	<opcodeparsed>

	//Arguments (cast if signed)
	<arguments; separator="\n">

	// Execute expressions
	<first(expressions):resultExpr()>
	<rest(expressions); separator="\n">

	return true;
}
>>

argument(name, signed) ::= <<
<if(signed)> <name> = (int) vm_convert_to_signed(<name>,<name>_bits); <endif>
>>

resultExpr(expression) ::= <<
<expression>
int R = result;
>>

ifExpr(conditio,ifExpr,elseExpr) ::= <<
if (<condition>) {
	<ifExpr; separator="\n">
}
<if(elseExpr)>
else {
	<elseExpr; separator="\n">
}
<endif>
>>

operatorExpr(word,operator,expression) ::= <<
<word> <operator> <expression> 
>>

assignExpr(var,type,value,comment,is_result) ::= <<
// <comment>
// Calculate expressions for the result var
result = <value>;
// Check if there was an error in the calculation of the result
if (error)
	return false;

<if(!is_result)>
if(!vm_write(state, diff, VM_INFO_<type>, <var>, result))
	return false;
<endif>
>>

condition(left,right) ::= <<
<left> == <right>
>>

wordVariable(variable, bit, type, not,constant) ::= <<
<if(not)>!<endif> <if(bit)>GetBit(<endif><if(!constant)>vm_info(state,VM_INFO_<type>,<endif><variable><if(!constant)>,&error)<endif><if(bit)>, <bit>)<endif>
>>

halt() ::= <<
	state->stopped_running = true;
        return false;
>>
